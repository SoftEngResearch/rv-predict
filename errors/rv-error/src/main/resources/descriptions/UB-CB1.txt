According to ISO C11, if a function is defined without a prototype (i.e. as an old-style function declaration), when the function is called, the default argument promotions are applied to the arguments of the function. If the type after the promotions are applied is not compatible with the declared type of the parameter in the function definition, this triggers undefined behavior. In practice, this can lead to memory corruption errors at runtime because the code generated for the function is incompatible with the data passed to the function on the stack and in registers. The correct solution is to avoid using old-style function declarations in your code, and instead define the function using a prototype which provides the correct types of the parameters to the function.
