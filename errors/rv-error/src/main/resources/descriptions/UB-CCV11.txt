According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.
