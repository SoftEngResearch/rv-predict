According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of "array object" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.
