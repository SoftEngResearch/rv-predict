According to ISO C11, if a pointer is converted to an integer and the value of the pointer cannot be represented in the integer type, the behavior is undefined. Because the address space of the application is unspecified, it is generally impossible to assume that a pointer converted to an integer will never be outside the range of representable values unless the integer type is at least as wide in number of bits as the size of a pointer. Thus, when converting from a pointer to an integer, you should always use an integer type as big as or bigger than the size of a pointer. However, furthermore, the resulting integer value of the conversion is implementation-defined, so if your goal is to be strictly conforming, you must stick to using the intptr_t and uintptr_t types defined in stdint.h which are guaranteed to preserve the value of a pointer between conversions to and from integers. In practice, this error can lead to memory corruption errors if the resulting integer value is ever converted back to a pointer type and used.
