According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.
