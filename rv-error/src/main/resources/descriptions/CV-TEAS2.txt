According to ISO C11, it violates a constraint to assign a value of one pointer type to a value of an incompatible pointer type unless one of the values is a void pointer, or the value being assigned is a null pointer constant. In practice, this can be a compiler error, however, some compilers relax this restriction and allow assignments between different pointer types without first performing a conversion. The correct solution is to avoid assigning pointers to one type to a value of a pointer of another type, except accorfding to the allowed exceptions. A user could cast the pointers to another type in order to perform the assignment, however, it would still be undefined behavior to dereference the pointer in this case due to the strict aliasing rules of C.
