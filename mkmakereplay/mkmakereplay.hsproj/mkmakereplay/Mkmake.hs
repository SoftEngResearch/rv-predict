{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE AllowAmbiguousTypes #-}

module Main where
  
import Data.Char
import Data.List
import Debug.Trace

import System.FilePath.Windows as FP

import qualified Data.Map.Strict as M
import qualified Data.ByteString.Lazy as BL

import Data.Csv
import qualified Data.Vector as V

{- = =================================================================== =
   = ========================================================================== =  
   =  Program to read procmon.exe CSV file (generated on Windows) and 
   = select the data needed to create makefiles. The data is huge
   = every read, every write, every reference to the registry creates 
   = an entry in the csv file.
   =
   = ========================================================================== =  
   =  The procmon column headings are:
   =  "Time of Day","Process Name","PID","Operation","Path","Result","Detail"
   = ========================================================================== =
   =
   = Program sections/steps: 
   = 1. loadTable: Reads Qtab file for the names of compilers (like cc1.exe) 
   =             and inserts then compiler titles into the table 
   =      qtabFileTitle  returns the file title with list of compiler names
   =      getQtabContent returns the compiler names as a string no
   =                  need for a file
   =              Comment one out to get the other        
   = 2. processCSVfile: reads a large (hundreds of mega-bytes) CSV file,
   =    loads each relevant line into record (Rec), and hands the record off to us
   =    for processing.
   = 3. Simple minded routines to dump table
   = 4. Read table and generate a makefile
   =
   = Notes:
   = * See isOpIgnorable (below) for csv lines totally ignored
   = * The input file titles are provided by the routines:
   =    qtabFileTitle The file with list of compiler names
   =    csvFileTitle  The csv data file generated by procmon 
   = * Conventional formal parameter names:
   =    rr    Instance of Rec, the decoded current line of the CSV file 
   =    tbl   The table which is constantly updated with procmon info
   =          and turned into a list to generate a makefile
   = =================================================================== =
   = =================================================================== =          
-}
{- = =================================================================== =
   = ===========The CSV lines with these operations always ignored ===== =
   = =================================================================== =
-} 
isOpIgnorable op =
  case op of
    "QueryNameInformationFile"    ->True
    "QueryDirectory"    -> True
    "RegOpenKey"    -> True 
    "RegCloseKey"    -> True 
    "RegQueryValue"    -> True     
    "CreateFileMapping"    -> True
    "QuerySecurityFile"    -> True  
    "Thread Create"    -> True 
    "Thread Exit"    -> True
    "Process Start"    -> True       
    "Process Exit"    -> True 
    "Load Image"    -> True    
    _     -> False
      
 
{- = =================================================================== =
   = =================================================================== =      
   = ===========Read in table data from .qtab file ===================== =
   = =================================================================== =      
   = =================================================================== =
-} 
--getQtabContent=  readFile qtabFileTitle

   -- Using inline string instead of file
   -- list of compilers and snowy as marker
getQtabContent = return "Ignore.me\ngcc.exe\ncc1.exe\nrealgcc.exe\n\nSnowy"
                      
loadTable :: IO (M.Map String Kynd)
loadTable = do 
     content <- getQtabContent
     tr  "======= loaded ========"           
     return (M.fromList $ fmap (\nam -> (nam, CompilerExe) ) $ lines content)
     
{- = =================================================================== =
   = ============== Symbol Table  ================================= =
   = ============== or just the table (Data.Map.Strict)  ============ =
   =  Each table entry is a (key,value) pair.
   = The value is of type Kynd - very simple
   = There are differant styles of keys for distinct purposes
   = * keys for names of compilers (cc1.exe)
   = * keys specifying programs to ignore (procmon.exe)
   = * keys specifying PIDs to ignore
   = * several long keys for to pass info to the make file
   =   generator.
   =    -specific keys for files (.h, .c, ..)
   =    -key for the compiler for each compilation instance
   = 
   =
   = =================================================================== =
   -} 

data Kynd = Exe
          | CompilerExe -- This is the name of a compiler to watch for
          | Compilation -- This is a pid doing compilation 
                        -- For this pid - We collect data  
          | ReadingFile
          | WritingFile
          | RdWrtngFile
          | Ignore
          | Whatever
         deriving (Show, Eq, Ord)
         
{- = =================================================================== =
   = This is the only code to reference the Map functions
   = =================================================================== = 
-}
isMember ky tbl     = M.member ky tbl

getSymVal :: Ord k => k -> M.Map k a -> Maybe a          
getSymVal ky tbl    = M.lookup ky tbl

isSymVal :: (Eq a, Ord t) => t -> a -> M.Map t a -> Bool             
isSymVal ky val tbl =  let vv = getSymVal ky tbl
                        in case vv of
                            Just kk -> kk == val
                            Nothing -> False
              
putSymVal ky vv tbl  = M.insert ky vv tbl 
                                       
{- = ====================================================================== =
   = Every insert, query, and table key generation is in this code block    =
   = ====================================================================== = 
-} 
           {- Query routines -}
isPidCompilation rr tbl  = isSymVal (mksymxPidNameKy rr)  Compilation  tbl
isPidTracked     rr tbl  = isSymVal (mksymxPidNameKy rr)  Compilation  tbl

getFylentry    nn rr tbl = getSymVal (mksymxFylKy nn rr) tbl

isCompiler       rr tbl  = isSymVal (pName rr) CompilerExe $ tbl
isIgnoredName    rr tbl  = isSymVal (pName rr) CompilerExe $ tbl

           {- Routines to add to table -}
putPidisCompilation rr tbl = putSymVal (mksymxPidNameKy  rr)  Compilation tbl     
putFylentry nn rr valu tbl = putSymVal (mksymxFylKy nn rr)    valu      tbl


createIgnore :: Ord k => k -> t -> M.Map k Kynd -> M.Map k Kynd
createIgnore ky rr tbl = putSymVal ky Ignore tbl
  
putIgnore rr tbl = putSymVal (pName rr)  Ignore tbl

{- = ====================================================================== =
   = All routines to generate table keys are here  =
   = ====================================================================== = 
-}                 
mksymxPidNameKy      rr = umksymxPidName rr
mksymxFylKy       nn rr = umksymxPidEntry  nn rr ++  " F: " ++ pPath rr

mksymxIgCompileRecKy rr = mksymxFylKy 9 rr  -- This is unexpected - we ignore
                                            -- But report it for review
                                   ++ " op="   ++ oPeration rr
                                   ++ " Path=" ++ pPath rr
 
umksymxPidName rr       = "P-" ++ (pPid rr) ++ ":" ++ (pName rr) ++ "$"
umksymxPidEntry nn rr   = umksymxPidName rr  ++ " " ++ show nn


{- = =================================================================== =
   = ============== Putting entries into the table  ============ =
   = 1. doSetupcompiling inserts the symbol table entry used to 
   =     determine if a PID is a compilation
   = 2. doCompilingRec handles all records of a compilation
   =
   = =================================================================== = 
-}
   
{- = =================================================================== =
 =   Compilation entries in the symbol table are ordered to facilitate   =
 = generation of makefiles
 =   The key is “P-“ pid  N g “:” text
 =                           Where pid is the Windows Process Id
 =                                      N is an ordering digit
 =                                       g == ‘F’ for files
 =                         “00:” Compiler entry for Compilation sequence
 =                         “2F:”  .h file      <text> is file title
 =                         “3F:” .opt like files
 =                         “4F:"    other files
 =                         “6F:"  .c file
 =
 = =================================================================== = 
 -} 


{- = =================================================================== =
   = ==============Start a ‘Compiling” pid  ============= =
   = =================================================================== = 
-}
   
doSetupCompilation rr tbl=
        let nam     = pName rr 
            symky   = mksymxPidNameKy rr
        in 
           if    isCompiler rr   tbl   
              && (not (isPidCompilation rr tbl))
            then putPidisCompilation rr tbl -- This Pid is compilation
            else trace (symky ++ nam) tbl

{- = =================================================================== =
   = ==============Handle compilation records   ======================== =
   = =================================================================== = 
-}  

isOpFile op = 
           case op of
            "ReadFile"  -> True
            "WriteFile" -> True
            "CreateFile"-> True
            "CloseFile" -> True
            _   -> False

genCompFylnn  rr  =
     let ext = takeExtensions $ pPath rr
         -- ext  = trace ("ext=" ++ ext' ++ "--" ++ nam) ext'
         nn  = case ext of 
                  ".h"   -> 2
                  ".opt" -> 3
                  ".c"   -> 6
                  _     -> 4
      in nn
                     
doCompileFyl op  rr tbl =
  let 
       nn    = genCompFylnn rr  
       val   = getFylentry nn rr tbl        
  in case val of
     Nothing -> case oPeration rr of 
                     "ReadFile"   ->putFylentry nn rr  ReadingFile   tbl
                     "WriteFile"  ->putFylentry nn rr  WritingFile   tbl
                     _            -> tbl  -- Ignore all other recs with file info
  
     Just  zz -> case (op,zz) of
                   ("ReadFile", ReadingFile) -> tbl -- All is well no change
                   ("WriteFile",WritingFile) -> tbl
                   ("ReadFile", RdWrtngFile) -> tbl 
                   ("WriteFile",RdWrtngFile) -> tbl
                   ("ReadFile", WritingFile) -> putFylentry nn rr RdWrtngFile tbl
                   ("WriteFile",ReadingFile) -> putFylentry nn rr RdWrtngFile tbl
                   ("CreateFile", _ )    -> 
                                      let 
                                           txt = " ?? "
                                           ky = mksymxIgCompileRecKy rr
                                       in utilAddIf1stIgnore (ky) rr tbl 
                   ("CloseFile",  _ )    -> tbl -- Ignore                               
                   _    -> ignored rr tbl
  
        
doCompilingRec  pid  op rr tbl =
      let opisfyl = isOpFile op
      in if opisfyl
          then doCompileFyl op rr tbl
          else tbl
  
{- = =================================================================== =
   = ==============routines to support 1st level decoding of the lyn  ============= =
   = =================================================================== = 
-}
{- = =================================================================== =
   = ============== write/util routines to operational use  ============= =
   = Every non debugging write should be here
   = Every creation of ignorable records should be here
   =  - The idea is that we can determine what records are being ignored
   =   in case we might need to unignore them
   = =================================================================== = 
-}
trIgnoringExe :: Rec -> a -> a
trIgnoring    :: Rec -> a -> a
trIgnoringExe rr tbl = trace ("Ignoring exe: " ++ pName rr) tbl
trIgnoring    rr tbl = trace ("Ignoring: "     ++ pName rr
                                  ++" op:" ++ oPeration rr) tbl

ignored :: t1 -> t -> t
ignored rr tbl = tbl -- Here is where we would count ignored records
  

ignoreThisExe :: Rec -> M.Map String Kynd -> M.Map String Kynd                               
ignoreThisExe rr tbl = 
          if  isIgnoredName rr tbl  
          then tbl  -- we are ignoring this exe
          else -- Make the ignored entry and emit trace
            createIgnore (pName rr) rr $ trIgnoringExe rr tbl
            
utilAddIf1stIgnore
       :: Ord k => k -> Rec -> M.Map k Kynd -> M.Map k Kynd 
utilAddIf1stIgnore ky rr tbl =
             let vv = getSymVal ky tbl 
             in case vv of 
                Just vv -> -- It's in the table -  ignore it
                          ignored rr tbl
                Nothing -> -- Add to table so we can ingnore it in the future
                       createIgnore (ky) rr $ trIgnoring rr tbl               

{- = =================================================================== =
   = ============== let's doit   ============= =
   = =================================================================== = 
-}                          
doPotentialCompilationRec :: Rec -> M.Map [Char] Kynd -> M.Map [Char] Kynd
doPotentialCompilationRec rr tbl=
  let nam  = pName rr
      pid  = pPid rr
      op   = oPeration rr
      fyl  = pPath rr
      pidIsTracked    = isPidTracked rr tbl 
      itsaCompilerExe = isCompiler rr tbl                    
  in 
     if isOpIgnorable op
     then tbl
     else 
      if itsaCompilerExe && op == "CreateFile"
      then tbl   -- Compiler makeing directories or whatever  
      else if pidIsTracked 
         then  doCompilingRec pid op rr tbl   -- Give to compilation handler 
         else if isCompiler rr tbl 
                     then -- Start a compilation 
                         doSetupCompilation  rr tbl -- (trIg 14 rr tbl)
                     else -- Ignore the record
                         ignoreThisExe rr tbl
         
{- = =================================================================== =
   = ============== Read the csv file and handle each line ============= =
   = =================================================================== = 
-}         
handleInputLyn :: Rec -> M.Map String Kynd -> M.Map String Kynd 
handleInputLyn rr tbl = 
      let  val = getSymVal exenam  tbl
           exenam = pName rr
           op     = oPeration rr
      in case isOpIgnorable op of
         True -> tbl -- Ignore the recorde no trace no nuttin
         False 
           -> case  val of
                 Nothing  ->  putIgnore rr  tbl -- Let the world know we ignore
                 Just vvv  -> case vvv of
                            Ignore  ->  ignored rr tbl
                            _       ->  doPotentialCompilationRec  rr tbl 

{- = ======================================================================== =
   = ============= Read the procmon csv file ================================ =
   = ======================================================================== =
   =      cassava (import Data.Csv) 
   = ======================================================================== = 
   =                                                                          = 
   =   The cassava library reads the csv records generated by procmon         =  
   = running on a Windows system.                                             = 
   =                                                                          =    
   =   We supply FromNamedRecord to copy data to our record Rec               = 
   =                                                                          = 
   =   The cassava routine decodeByName reads the file                        = 
   =            generating a list of Rec                                      = 
   =                 which we process via foldr                               = 
   =                       invoking our routine handleInputLyn.               =                                                          
   =                                                                          = 
   = ======================================================================== =    
   =   Note that the whole input process took only a dozen or lines of code.  = 
   =                 It's magic!!!                                            = 
   = ======================================================================== = 
   =   The procmon column headings are:                                       = 
   = "Time of Day","Process Name","PID","Operation","Path","Result","Detail"  = 
   = ======================================================================== = 
   = ======================================================================== = 
-}
data Rec = Rec 
    { pName      :: !String
    , pPid       :: !String    
    , oPeration  :: !String
    , pPath      :: !String
    }
  
instance FromNamedRecord Rec where
    parseNamedRecord r = breakOnMe 
                       $ Rec <$> r .: "Process Name"
                             <*> r .: "PID"
                             <*> r .: "Operation"
                             <*> r .: "Path"
                              
getCSVdata = BL.readFile csvFileTitle
  
processCSVfile :: M.Map String Kynd -> IO (M.Map String Kynd)
processCSVfile tbl = do
    csvData <- getCSVdata
    trace "Read csv data" return ()
    case decodeByName csvData of
        Left err -> error err
        Right (_, v) -> return $ foldr handleInputLyn tbl v
        
{- = =================================================================== =
   = ============== debugging routines  ============= =
   = =================================================================== = 
-} 
breakOnMe x = x
--breakMer x=return x
{- = =================================================================== =
   = ============== trace stuff  ============= =
   = =================================================================== = 
-}
strRR01 hd rr = hd ++ pPid rr 
                ++ ":" ++ oPeration rr           
                ++ ":" ++ pName rr
                ++ " path>" ++ pPath rr
                
strKyV ky vv = "(ky=>" ++ ky ++ "," ++ vv ++")"
   
{-
 - Some trace routines 
 -}
tr  x  = putStrLn x
 
trIg kk rr tbl =
  let qq1 = "Trc>"++ show kk ++ ">"
      qq2 = strRR01 qq1 rr
  in if kk <1000
     then trace  qq2 tbl
     else tbl  
     
{- = =================================================================== =
   = ============== Symbol table trace/display utilities ============= =
   = =================================================================== = 
-}

prtbl0 :: (Show a1, Show a) => (a1, a) -> IO ()
prtbl0 (k ,v) =tr  $ "Tbl=" ++ show v ++ ":" ++ show k 

dumpSymTable1 sss tbl = do
   x <- trace sss (return ()) 
   y <- traverse prtbl0 (M.toList tbl) 
--   y <- traverse prtbl0 theList
   return ()    
                               
dumpSymTableOrdered tbl =
  let xs = M.toAscList tbl
   in show xs  
  
dumpEntry (kkvv) =  ("\n" ++ show (fst kkvv) 
                          ++ " : " show (snd kkvv))         
dumpSymTableOrdered' tbl = do
   x <- trace "ordered" (return ()) 
   y <- traverse prtbl0 (M.toList tbl) 
   return ()  
         

{- = =================================================================== =
   = =================================================================== = 
   = ============== make the make file  ============= =
   = ============== 1. get the symbol table as ordered list
   = ============== 2. traverse the list using fold (accum4MkFragment)
   = ==============   invoking createMkFylfromTbl to create an 
   = ==============   instance of Qacum
   = ============== 3.
   = ==============
   = ==============
   = =================================================================== = 
   = =================================================================== = 
-}

{- = =================================================================== =
   = ============== some text routines  ============= =
   = =================================================================== = 
-}
matchTillChar c (x:s1) (y:s2) = if x == y
                              then if x == c
                                   then True
                                   else matchTillChar c s1 s2
                              else False
matchTillChar   _  _  _      = True


splitEm :: Char -> String -> (String,String)
splitEm c str=
      go str []
      where 
        go [] (pp) = (pp,[])
        go (x:xs) (pp) = if x == c
                              then  -- trace ("SplitEm:(" ++ pp ++ "," ++ xs ++ ")" )
                                  (pp,xs)
                              else go xs (pp ++ [x])
                              
{- = =================================================================== =
   = ============== Qacum - the info about a compilation  ============= =
   = =================================================================== = 
-}


 
                              
data Qacum = Qacum
    { currKy   :: String
 --   , prevV    :: Kynd 
    , myPid    :: String 
    , blding   :: Bool
    , compiler :: String
    , compFyl  :: String
    , target, src :: String
    , inclFyls :: [String]
    , unkFyls  :: [String]
    , srcComment :: String 
    } deriving (Show )
  
{- = =================================================================== =
   = ============== Qacum (qq) utility routines ============= =
   = =================================================================== = 
-} 
qacumNull = Qacum { currKy = " " 
   --               , prevV = Whatever
                  , blding =False 
                  , myPid = " "
                  , compiler = " " ,compFyl = " "
                  , target = " ", src = " " 
                  , inclFyls=[], unkFyls=[]
                  , srcComment= " "
                  }
                  
addTargetSrc targetname filename qq =
              qq {target = targetname
                 , src= filename }

addInclFyl compname fylName vv qq =
           qq { blding = True 
              , compiler = compname
     --         , prevV = Compilation
              , inclFyls = inclFyls qq ++ [fylName] }

addunkFyl compname fylName vv qq =
           qq {  blding = True , compiler = compname
          --         , prevV = Compilation
              , unkFyls =  unkFyls qq ++ [fylName] }

{- = =================================================================== =
   = ============== Qacum (qq) trace routines ============= =
   = =================================================================== = 
-}   
trqq sss ky vv qq = if not $ blding qq
                    then trace (sss ++ ky ++ ":" ++ show vv++"   >>"++show qq) qq
                    else trace (">>>>> " ++ compiler qq 
                               ++ " Ky=" ++ currKy qq
                               ++ ">>>" ++ ky) 
                          qq
                               
xtrqq sss qq =
      trace ("                     =pKy=>" ++ currKy qq 
                                              ++ " Bldng=" ++ (if blding qq
                                                             then "T" else "F"))
      trace ("                     ="      ++ compiler qq ++ "@" ++ compFyl qq)
        qq 
        
qqSum1 qq = 
      let
        tf = if (blding qq) then "Tr:" else "Fl:"
      in  tf    ++  currKy qq ++ " "
           
{- = =================================================================== =
   = ============== Routines to write out the makefile fragment ============= =
   = =================================================================== = 
-} 
wrInclFiles qq qqout=
     go  (reverse (inclFyls qq))
     where go []  = qqout
           go (x:xs) =  go  ( trace ("        |     " ++ x ++ "  \\")  
                          xs) 
wrUnkFiles qq qqout=
     go  (unkFyls qq)
     where go []  = qqout
           go (x:xs) =  go  ( trace ("        |#           " ++ x )  
                          xs)  
wrHdr qq qqout =                         
  trace ("        |# Makefile based on procmon.exe trace of PID " ++ myPid qq )
  (if (unkFyls qq) == []
  then qqout
  else 
     trace ("        |# the following files were read by the compiler " )
     (wrUnkFiles qq)
     qqout
  )
                                 
wrMakeSkel qq =
  trace ( "Make    |# Make generated by RV (v0.0.0) "   )
  (wrHdr qq)
  trace ("        |CC=" ++ compiler qq )
  trace ("        |" ++ target qq ++ ":  \\")
 (wrInclFiles qq)
  trace ("        |        " ++ src qq)
  trace ("        | $(CC) "   ++ target qq )
  qq 
               
{- = =================================================================== =
   = ============== accum4MkFragment   ============= =
   =  If the incoming (ky,vv) ky is new
   =     and currently building an Qaccum
   =    then hand the Qaccum off to create a makefile fragment.    
   =  Start a new Qaccum                   
   = =================================================================== =  
 -}
finishCompilationAccum qqin =
          let
            dumpMkFrag        = wrMakeSkel (xtrqq "MkSkel" qqin)
            nullq             = qacumNull
          in   dumpMkFrag
          
startNewCompilationAccum (ky,vv) qqin =
                 accum4MkFragment (ky,vv) qqin

handleTableEl  (ky,vv) (qqin,qqlst) =
    let
      didKyChange       = not $ matchTillChar '$' ky (currKy qqin)
      qqFinal           = finishCompilationAccum qqin
      accumWith qqq     = accum4MkFragment (ky,vv) qqq
      updqqin             = accumWith qqin
    in case (blding qqin, didKyChange ) of
       (True, False) -> -- We are building an entry - carry on 
                       (accumWith qqin,qqlst)
       (True, True ) -> -- Current compilation sequence over
                       (accumWith  qacumNull, qqFinal:qqlst)
       _            -> (updqqin,qqlst)
  
          
accum4MkFragment :: (String,Kynd) -> Qacum -> Qacum   
accum4MkFragment (ky,vv) qqin =   
      let 
        -- Split key up
        -- "P-6600:cc1.exe$ 2 F: C:\\Users\\RV1\\OneDrive\\RV\\8-C-src\\t0614x1.h"
        (pid,remKy1)      = splitEm ':' ky
        (compname,remKy2) = splitEm '$' remKy1
        fylName           = drop 5 remKy2 -- skip " 2 F:"
        finfo             = take 5 remKy2
        fyldigit          = take 1 $ drop 1 finfo
        -- Function exit values
        xitv_no_change     = qqin
        -- Check if key changed, handle make fragment if needed,
        didKyChange       = not $ matchTillChar '$' ky (currKy qqin)       
        -- gen empty Qacum for next compile
        
        xitv_after_check  = if  didKyChange && blding qqin
                            then wrMakeSkel (xtrqq "MkSkel" qqin)
                            else xitv_no_change
        xitv_new_compile  = -- incoming record could be part of a compilations
                            -- if ??
                            if  didKyChange && blding qqin
                            then wrMakeSkel (xtrqq "MkSkel" qqin)
                            else qqin
        -- Grap pid, compiler name, .. and stuff into Qacum
        -- Do this for every entry -- There is no entry that is always present and 1st
        
        mkCompileing   qqq   = if blding qqq
                                then qqq 
                                else qqq { blding = True, compiler = compname
                                               , myPid = pid
                                           --    , prevV = vv
                                               , currKy = ky}
        set2Compilation qq   = mkCompileing qq
        
        qq'                = set2Compilation qqin                                        
        qq''               = set2Compilation xitv_after_check

        -- Fiddle with file path
        mkTargetName      = if FP.takeExtension ky == ".c"
                            then (FP.takeBaseName ky ++ ".exe")
                            else (FP.takeBaseName ky ++ ".???")
  

        

      in case vv of
          Ignore      -> trace ( "Ig -->"++ ky ++ ":" ++ show vv)  xitv_after_check
          Compilation -> xtrqq "Compilation" $ qq''
          ReadingFile -> trace ("RF -->" ++ qqSum1 qq' 
                                            ++ finfo ++ "   "
                                            ++ pid ++ ":" ++ compname ++ ":"
                                            ++ fylName )
                          ( case fyldigit of
                              "6" ->   -- add target file name (ie xyz.exe)
                                     addTargetSrc mkTargetName
                                                 (FP.takeFileName ky)--
                                                 qq''
                              "2" ->  addInclFyl compname fylName vv  qq''
                              "4" ->  addunkFyl  compname fylName vv  qq''
                              _   -> trace ( "Bad fylDigit-->" ++ fyldigit 
                                             ++ ">->" 
                                             ++ ky ++ "::" ++ show vv)  qq''
                           )
          
          _           -> trace ( "Why rf-->" ++ qqSum1 qq' ++ ">->" 
                           --      ++ pid ++":"++ compname
                           --      ++ "Fyl=" ++ fylName 
                                 ++ ">=>"++ ky ++ "::" ++ show vv) qq'


                  
{- = =================================================================== =
   = ============== Create make file  ============= =
   =  Traverse the table as an ordered list (using foldr)
   = invoking accum4MkFragment for each element         
   = =================================================================== =  
 -}
theList :: M.Map String Kynd -> [(String,Kynd)]
theList tbl = M.toList tbl

createMkFylfromTbl  ::Monad m => M.Map String Kynd -> m Qacum
createMkFylfromTbl  tbl = do 
   return $ foldr  accum4MkFragment qacumNull   (theList tbl)


                             
{- = =================================================================== =
   = ============== Main ============= =
   = =================================================================== =
   = qtabFileTitle  returns the name of the qtab file                    =
   = csvFileTitle   returns the name of the csv file created by procmon
   = =================================================================== =  
 -}
--qtabFileTitle = "../../tabl1.qtab"
   {- ============= csv files ============ -}

-- Has column headings enquoted - Fails
--csvFileTitle  = "./tests/99ProcMonFiles/6hasQuotes/20180620PMonLogfile1039.CSV"
--csvFileTitle  = "./tests/99ProcMonFiles/99Logfiles/6hasQuotes/00-Logfile.csv"
   -- Runs ok with quotes
--csvFileTitle  = "./tests/99ProcMonFiles/6hasQuotes/99-short0.csv" -- No compile entries
-- No Quote - runs ok
csvFileTitle  = "./tests/99ProcMonFiles/7NoQuote/20180620PMonNoQuote.CSV"

main :: IO ()
main  = do
   table <- loadTable
   dumpSymTable1 "Initial load" table
   tr "========================= CSV Processing commences =============="
   tr ( "==================== file:" ++ csvFileTitle ++ "=========" )
  
   table' <- processCSVfile table
   --tr "========================= Final Table ==========================="
   dumpSymTable1 "After CSV table" table'  
   tr "========================= generating output ==================="
   ttt <- createMkFylfromTbl  table'
   --dumpSymTable1 "After CSV table" ttt
   tr ( " nn "++currKy ttt) 
   tr "done"


